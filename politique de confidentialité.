-- Création des extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" SCHEMA extensions;

-- Création du schéma si nécessaire
CREATE SCHEMA IF NOT EXISTS consent_management;

-- Table de consentement principale
CREATE TABLE consent_management.user_consents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Consentements granulaires
    marketing_email_consent BOOLEAN DEFAULT FALSE,
    marketing_sms_consent BOOLEAN DEFAULT FALSE,
    marketing_push_consent BOOLEAN DEFAULT FALSE,
    
    analytics_tracking_consent BOOLEAN DEFAULT FALSE,
    personalization_consent BOOLEAN DEFAULT FALSE,
    third_party_sharing_consent BOOLEAN DEFAULT FALSE,
    
    -- Métadonnées
    consent_version TEXT NOT NULL DEFAULT 'v1.0',
    consent_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Informations contextuelles
    consent_ip_address INET,
    consent_user_agent TEXT,
    consent_location JSONB
);

-- Table de journal des modifications
CREATE TABLE consent_management.consent_logs (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    
    previous_consents JSONB,
    new_consents JSONB,
    change_type TEXT NOT NULL,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT
);

-- Politique de sécurité pour la table de consentements
ALTER TABLE consent_management.user_consents ENABLE ROW LEVEL SECURITY;
ALTER TABLE consent_management.consent_logs ENABLE ROW LEVEL SECURITY;

-- Politique RLS pour les consentements
CREATE POLICY "Users can manage own consents" 
ON consent_management.user_consents
FOR ALL 
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Politique RLS pour les journaux de consentement
CREATE POLICY "Users can view own consent logs" 
ON consent_management.consent_logs
FOR SELECT 
USING (auth.uid() = user_id);

-- Fonction de trigger pour journaliser les modifications
CREATE OR REPLACE FUNCTION consent_management.log_consent_changes()
RETURNS TRIGGER AS $$
BEGIN
    -- Insérer un enregistrement dans le journal des modifications
    INSERT INTO consent_management.consent_logs (
        user_id, 
        previous_consents, 
        new_consents, 
        change_type, 
        ip_address, 
        user_agent
    ) VALUES (
        NEW.user_id,
        (SELECT to_jsonb(row) FROM (SELECT * FROM consent_management.user_consents WHERE user_id = NEW.user_id) row),
        to_jsonb(NEW),
        CASE 
            WHEN TG_OP = 'INSERT' THEN 'INITIAL'
            WHEN TG_OP = 'UPDATE' THEN 'UPDATE'
            ELSE 'UNKNOWN'
        END,
        NEW.consent_ip_address,
        NEW.consent_user_agent
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Création du trigger
CREATE TRIGGER consent_change_trigger
AFTER INSERT OR UPDATE ON consent_management.user_consents
FOR EACH ROW 
EXECUTE FUNCTION consent_management.log_consent_changes();
